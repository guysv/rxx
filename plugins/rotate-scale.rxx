// rotate-scale.rxx - selection rotate and scale via visual modes

fn init() {
    // draw constants
    const PIVOT_HALF = 6.0;
    const PIVOT_COLOR_UNLOCKED = rgb8(0xff, 0xff, 0x00);
    const PIVOT_COLOR_LOCKED = rgb8(0xff, 0xff, 0xff);

    // visual modes
    let rotation_mode = script_mode("visual (rotation)");
    let scale_mode = script_mode("visual (scale)");

    // rotation state
    let rotation_angle = 0.0;
    let accumulated_angle = 0.0;

    // scale state
    let scale_x = 1.0;
    let scale_y = 1.0;
    let accumulated_scale_x = 1.0;
    let accumulated_scale_y = 1.0;

    // interaction state
    let pivot = ();
    let pivot_locked = false;
    let drag_start = ();
    let last_p = ();

    // operation state
    let clipboard = renderer.create_render_texture(8, 8);
    let in_progress = false;
    let pasted_once = false;
    let active_view_id = ();
    let apply_queue = script_queue;
    session.init_setting("rotate-scale/algo", "rotsprite-gl.rxx/render_pass");

    register_command("selection/rotate", "Rotates the selection");
    register_command("selection/scale", "Scales the selection");

    print(`rotate-scale.rxx initialized`);
}

// ---------------------------------------------------------------------------
// Commands
// ---------------------------------------------------------------------------

fn cmd_selection_paste(args) {
    if !in_progress {
        return false;
    }
    apply_queue.push("draw_to_render");
    session.touch_active_view();
    return true;
}

fn cmd_selection_rotate(args) {
    if session.selection == () {
        return true;
    }
    drag_start = ();
    last_p = ();
    pivot_locked = false;
    in_progress = true;
    pasted_once = false;
    rotation_angle = 0.0;
    accumulated_angle = 0.0;
    let selection = session.selection;
    pivot = selection.center();
    active_view_id = session.active_view_id;
    renderer.upload_selection_to_texture(session, clipboard);
    queue_active_view_rect_clear(selection);
    session.switch_mode(rotation_mode);
    return true;
}

fn cmd_selection_scale(args) {
    if session.selection == () {
        return true;
    }
    drag_start = ();
    last_p = ();
    pivot_locked = false;
    in_progress = true;
    pasted_once = false;
    scale_x = 1.0;
    scale_y = 1.0;
    accumulated_scale_x = 1.0;
    accumulated_scale_y = 1.0;
    let selection = session.selection;
    pivot = selection.center();
    active_view_id = session.active_view_id;
    renderer.upload_selection_to_texture(session, clipboard);
    queue_active_view_rect_clear(selection);
    session.switch_mode(scale_mode);
    return true;
}

// ---------------------------------------------------------------------------
// Lifecycle
// ---------------------------------------------------------------------------

fn unload() {
    if !in_progress {
        return;
    }
    if !pasted_once {
        queue_effect(effect_view_damaged(active_view_id));
    }
    if session.mode == rotation_mode || session.mode == scale_mode {
        session.switch_mode(MODE_NORMAL);
    }
}

fn switch_mode() {
    if !in_progress {
        return;
    }
    if session.prev_mode != rotation_mode && session.prev_mode != scale_mode {
        return;
    }
    in_progress = false;
    if !pasted_once {
        queue_effect(effect_view_damaged(active_view_id));
    }
}

// ---------------------------------------------------------------------------
// Input
// ---------------------------------------------------------------------------

fn mouse_input(state, button, cursor) {
    if session.mode != rotation_mode && session.mode != scale_mode {
        return;
    }
    let view = session.view(session.active_view_id);
    let d = view.zoom;
    let cursor = vec2(cursor.x + d / 4, cursor.y + d / 4);
    let p = session.active_view_sub_coords(cursor, 2);

    // right-click: set or clear pivot (only before first drag)
    if state == INPUT_STATE_PRESSED && button == MOUSE_BUTTON_RIGHT && !pivot_locked {
        pivot = if p == pivot { () } else { p };
        return;
    }

    // left-click: start or end drag
    if state == INPUT_STATE_PRESSED && button == MOUSE_BUTTON_LEFT {
        drag_start = p;
    }
    if state == INPUT_STATE_RELEASED && button == MOUSE_BUTTON_LEFT {
        if session.mode == rotation_mode {
            accumulated_angle = rotation_angle;
        }
        if session.mode == scale_mode {
            accumulated_scale_x = scale_x;
            accumulated_scale_y = scale_y;
        }
        pivot_locked = true;
        drag_start = ();
        last_p = ();
    }
}

fn cursor_moved(p) {
    if drag_start == () {
        return;
    }
    let view = session.view(session.active_view_id);
    let zoom = view.zoom;
    let offset = vec2(session.offset_x + view.offset.x, session.offset_y + view.offset.y);
    let pivot_session = pivot * zoom + offset;

    if session.mode == rotation_mode {
        if p == pivot_session || p == drag_start || pivot_session == drag_start {
            return;
        }
        last_p = p;
        let drag_start_session = drag_start * zoom + offset;
        let angle = vector_angle(pivot_session, drag_start_session, p.to_vec2());
        rotation_angle = accumulated_angle + angle;
    }

    if session.mode == scale_mode {
        last_p = p;
        let drag_start_session = drag_start * zoom + offset;
        let dist_start = vector_distance(pivot_session, drag_start_session);
        let dist_now = vector_distance(pivot_session, p.to_vec2());
        if dist_start > 0.001 {
            let scale = dist_now / dist_start;
            scale_x = accumulated_scale_x * scale;
            scale_y = accumulated_scale_y * scale;
        }
    }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn vector_angle(pivot_pt, from_pt, to_pt) {
    let v1 = from_pt - pivot_pt;
    let v2 = to_pt - pivot_pt;
    let dot = v1.x * v2.x + v1.y * v2.y;
    let det = v1.x * v2.y - v1.y * v2.x;
    return atan(det, dot);
}

fn vector_distance(a, b) {
    let dx = a.x - b.x;
    let dy = a.y - b.y;
    return (dx * dx + dy * dy).sqrt();
}

// ---------------------------------------------------------------------------
// Draw
// ---------------------------------------------------------------------------

fn draw() {
    if session.mode != rotation_mode && session.mode != scale_mode {
        return;
    }
    let algo_addr = session.get_setting("rotate-scale/algo").as_string();
    if algo_addr != () {
        draw_text(vec2(10.0, 86.0), `Algorithm: ${algo_addr}`, rgb8(0xff, 0x33, 0x66));
        if session.mode == rotation_mode {
            draw_text(vec2(10.0, 66.0), `Angle: ${rotation_angle}`, rgb8(0xff, 0x33, 0x66));
        }
        if session.mode == scale_mode {
            draw_text(vec2(10.0, 66.0), `Scale: ${scale_x}, ${scale_y}`, rgb8(0xff, 0x33, 0x66));
        }
    }
    
    let view = session.view(session.active_view_id);
    let offset_x = session.offset_x + view.offset.x;
    let offset_y = session.offset_y + view.offset.y;
    let d = view.zoom;

    if pivot == () {
        return;
    }
    let x1 = pivot.x * d + offset_x;
    let y1 = pivot.y * d + offset_y;
    let pivot_color = if pivot_locked { PIVOT_COLOR_LOCKED } else { PIVOT_COLOR_UNLOCKED };

    // pivot crosshair
    draw_line(vec2(x1 - PIVOT_HALF, y1), vec2(x1 + PIVOT_HALF, y1), pivot_color);
    draw_line(vec2(x1, y1 - PIVOT_HALF), vec2(x1, y1 + PIVOT_HALF), pivot_color);

    if drag_start == () {
        return;
    }
}

fn shade(encoder) {
    if !in_progress {
        return;
    }
    let algo_addr = session.get_setting("rotate-scale/algo").as_string();
    if algo_addr == () || algo_addr == "" {
        throw "rotate-scale/algo setting is required";
    }
    let pass_fn = session.get_plugin_fn(algo_addr);
    let draw_to_render = apply_queue.pop() == "draw_to_render";
    let target_texture = if draw_to_render {
        renderer.view_render_texture(active_view_id)
    } else {
        renderer.view_staging_texture(session.active_view_id)
    };
    if draw_to_render {
        pasted_once = true;
    }

    let batch = renderer.sprite_singleton_batch(
        8, 8,
        rect(0.0, 0.0, 8.0, 8.0),
        session.selection.to_rect_f64(),
        0.0,
        rgb8(0, 0, 0, 0),
        if draw_to_render { 1.0 } else { 0.9 });
    let vertices = batch.vertices();

    let t1 = mat4_translation(-pivot.x, -pivot.y);
    let t2 = mat4_translation(pivot.x, pivot.y);
    let transform = if session.mode == rotation_mode {
        let r = mat4_rotation_z(rotation_angle);
        t2 * r * t1
    } else {
        let s = mat4_scale(scale_x, scale_y);
        t2 * s * t1
    };

    pass_fn.invoke([encoder, transform, target_texture, clipboard, vertices]);
}
