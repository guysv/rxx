// rotate-scale.rxx - selection rotate and scale via visual modes

fn init() {
    // draw constants
    const PIVOT_HALF = 6.0;
    const PIVOT_COLOR_UNLOCKED = rgb8(0xff, 0xff, 0x00);
    const PIVOT_COLOR_LOCKED = rgb8(0xff, 0xff, 0xff);

    // visual modes
    let rotation_mode = script_mode("visual (rotation)");
    let scale_mode = script_mode("visual (scale)");

    // rotation state
    let rotation_degrees = 0.0;
    let accumulated_rotation_degrees = 0.0;

    // scale state
    let scale_x = 1.0;
    let scale_y = 1.0;
    let accumulated_scale_x = 1.0;
    let accumulated_scale_y = 1.0;

    // interaction state
    let pivot = ();
    let pivot_locked = false;
    let drag_start = ();
    let last_p = ();
    let last_mode = ();

    // operation state
    let clipboard = renderer.create_render_texture(8, 8);
    let in_progress = false;
    let pasted_once = false;
    let active_view_id = ();
    let base_selection = ();
    let apply_queue = script_queue;
    session.init_setting("rotate-scale/algo", "rotsprite-gl.rxx/render_pass");

    register_command("selection/rotate", "Rotates the selection");
    register_command("rotate/set", "Sets selection rotation in degrees");
    register_command("rotate/add", "Adds delta rotation in degrees");
    register_command("selection/scale", "Scales the selection");
    register_command("scale/set", "Sets selection scale");
    register_command("scale/add", "Adds delta scale");

    print(`rotate-scale.rxx initialized`);
}

// ---------------------------------------------------------------------------
// Commands
// ---------------------------------------------------------------------------

fn cmd_selection_paste(args) {
    if !in_progress {
        return false;
    }
    apply_queue.push("draw_to_render");
    session.touch_active_view();
    return true;
}

fn cmd_selection_rotate(args) {
    if session.selection == () {
        return true;
    }
    drag_start = ();
    last_p = ();
    last_mode = rotation_mode;
    pivot_locked = false;
    in_progress = true;
    pasted_once = false;
    rotation_degrees = 0.0;
    accumulated_rotation_degrees = 0.0;
    let selection = session.selection;
    base_selection = selection;
    pivot = selection.center();
    active_view_id = session.active_view_id;
    renderer.upload_selection_to_texture(session, clipboard);
    queue_active_view_rect_clear(selection);
    session.switch_mode(rotation_mode);
    return true;
}

fn cmd_rotate_set(args) {
    if !in_progress || session.mode != rotation_mode {
        return true;
    }
    if args.len() != 1 {
        print("usage: rotate/set <degrees>");
        return true;
    }
    let degrees = parse_float(args[0]);
    let wrapped_degrees = wrap_rotation_degrees(degrees);
    rotation_degrees = wrapped_degrees;
    accumulated_rotation_degrees = wrapped_degrees;
    drag_start = ();
    last_p = ();
    return true;
}

fn cmd_rotate_add(args) {
    if !in_progress || session.mode != rotation_mode {
        return true;
    }
    if args.len() != 1 {
        print("usage: rotate/add <degrees delta>");
        return true;
    }
    let delta_degrees = parse_float(args[0]);
    let new_degrees = wrap_rotation_degrees(rotation_degrees + delta_degrees);
    rotation_degrees = new_degrees;
    accumulated_rotation_degrees = new_degrees;
    drag_start = ();
    last_p = ();
    return true;
}

fn cmd_selection_scale(args) {
    if session.selection == () {
        return true;
    }
    drag_start = ();
    last_p = ();
    last_mode = scale_mode;
    pivot_locked = false;
    in_progress = true;
    pasted_once = false;
    scale_x = 1.0;
    scale_y = 1.0;
    accumulated_scale_x = 1.0;
    accumulated_scale_y = 1.0;
    let selection = session.selection;
    base_selection = selection;
    pivot = selection.center();
    active_view_id = session.active_view_id;
    renderer.upload_selection_to_texture(session, clipboard);
    queue_active_view_rect_clear(selection);
    session.switch_mode(scale_mode);
    return true;
}

fn cmd_scale_set(args) {
    if !in_progress || session.mode != scale_mode {
        return true;
    }
    if args.len() != 2 {
        print("usage: scale/set <x scale> <y scale>");
        return true;
    }
    let new_scale_x = parse_float(args[0]);
    let new_scale_y = parse_float(args[1]);
    scale_x = new_scale_x;
    scale_y = new_scale_y;
    accumulated_scale_x = new_scale_x;
    accumulated_scale_y = new_scale_y;
    drag_start = ();
    last_p = ();
    return true;
}

fn cmd_scale_add(args) {
    if !in_progress || session.mode != scale_mode {
        return true;
    }
    if args.len() != 2 {
        print("usage: scale/add <x delta> <y delta>");
        return true;
    }
    let delta_x = parse_float(args[0]);
    let delta_y = parse_float(args[1]);
    let new_scale_x = scale_x + delta_x;
    let new_scale_y = scale_y + delta_y;
    scale_x = new_scale_x;
    scale_y = new_scale_y;
    accumulated_scale_x = new_scale_x;
    accumulated_scale_y = new_scale_y;
    drag_start = ();
    last_p = ();
    return true;
}

// ---------------------------------------------------------------------------
// Lifecycle
// ---------------------------------------------------------------------------

fn unload() {
    if !in_progress {
        return;
    }
    restore_base_selection_if_not_applied!();
    if !pasted_once {
        queue_effect(effect_view_damaged(active_view_id));
    }
    if session.mode == rotation_mode || session.mode == scale_mode {
        session.switch_mode(MODE_NORMAL);
    }
}

fn switch_mode() {
    if !in_progress {
        return;
    }
    if session.mode != MODE_COMMAND && session.mode != rotation_mode && session.mode != scale_mode {
        restore_base_selection_if_not_applied!();
        in_progress = false;
        if !pasted_once {
            queue_effect(effect_view_damaged(active_view_id));
        }
        if session.mode != MODE_VISUAL {
            session.clear_selection();
        }
    }
}

// ---------------------------------------------------------------------------
// Input
// ---------------------------------------------------------------------------

fn mouse_input(state, button, cursor) {
    if session.mode != rotation_mode && session.mode != scale_mode {
        return;
    }
    let view = session.view(session.active_view_id);
    let d = view.zoom;
    let cursor = vec2(cursor.x + d / 4, cursor.y + d / 4);
    let p = session.active_view_sub_coords(cursor, 2);

    // right-click: set or clear pivot (only before first drag)
    if state == INPUT_STATE_PRESSED && button == MOUSE_BUTTON_RIGHT && !pivot_locked {
        pivot = if p == pivot { () } else { p };
        return;
    }

    // left-click: start or end drag
    if state == INPUT_STATE_PRESSED && button == MOUSE_BUTTON_LEFT {
        drag_start = p;
    }
    if state == INPUT_STATE_RELEASED && button == MOUSE_BUTTON_LEFT {
        if session.mode == rotation_mode {
            accumulated_rotation_degrees = wrap_rotation_degrees(rotation_degrees);
        }
        if session.mode == scale_mode {
            accumulated_scale_x = scale_x;
            accumulated_scale_y = scale_y;
        }
        pivot_locked = true;
        drag_start = ();
        last_p = ();
    }
}

fn cursor_moved(p) {
    if drag_start == () {
        return;
    }
    let view = session.view(session.active_view_id);
    let zoom = view.zoom;
    let offset = vec2(session.offset_x + view.offset.x, session.offset_y + view.offset.y);
    let pivot_session = pivot * zoom + offset;

    if session.mode == rotation_mode {
        if p == pivot_session || p == drag_start || pivot_session == drag_start {
            return;
        }
        last_p = p;
        let drag_start_session = drag_start * zoom + offset;
        let angle_radians = vector_angle(pivot_session, drag_start_session, p.to_vec2());
        let angle_degrees = radians_to_degrees(angle_radians);
        rotation_degrees = wrap_rotation_degrees(accumulated_rotation_degrees + angle_degrees);
    }

    if session.mode == scale_mode {
        last_p = p;
        let drag_start_session = drag_start * zoom + offset;
        let dist_start = vector_distance(pivot_session, drag_start_session);
        let dist_now = vector_distance(pivot_session, p.to_vec2());
        if dist_start > 0.001 {
            let scale = dist_now / dist_start;
            scale_x = accumulated_scale_x * scale;
            scale_y = accumulated_scale_y * scale;
        }
    }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn vector_angle(pivot_pt, from_pt, to_pt) {
    let v1 = from_pt - pivot_pt;
    let v2 = to_pt - pivot_pt;
    let dot = v1.x * v2.x + v1.y * v2.y;
    let det = v1.x * v2.y - v1.y * v2.x;
    return atan(det, dot);
}

fn vector_distance(a, b) {
    let dx = a.x - b.x;
    let dy = a.y - b.y;
    return (dx * dx + dy * dy).sqrt();
}

fn radians_to_degrees(radians) {
    return radians * (180.0 / 3.141592653589793);
}

fn degrees_to_radians(degrees) {
    return degrees * (3.141592653589793 / 180.0);
}

fn wrap_rotation_degrees(degrees) {
    let wrapped = degrees - (degrees / 360.0).floor() * 360.0;
    if wrapped > 180.0 {
        wrapped = wrapped - 360.0;
    }
    return wrapped;
}

fn transformed_point(x, y) {
    let dx = x - pivot.x;
    let dy = y - pivot.y;
    if last_mode == rotation_mode {
        let rotation_radians = degrees_to_radians(rotation_degrees);
        let c = cos(rotation_radians);
        let s = sin(rotation_radians);
        return vec2(pivot.x + dx * c - dy * s, pivot.y + dx * s + dy * c);
    }
    return vec2(pivot.x + dx * scale_x, pivot.y + dy * scale_y);
}

fn current_transformed_bounds() {
    if base_selection == () || pivot == () {
        return ();
    }
    let r = base_selection;
    let p1 = transformed_point!(r.x1, r.y1);
    let p2 = transformed_point!(r.x2, r.y1);
    let p3 = transformed_point!(r.x2, r.y2);
    let p4 = transformed_point!(r.x1, r.y2);

    let min_x = min(min(p1.x, p2.x), min(p3.x, p4.x)).floor();
    let min_y = min(min(p1.y, p2.y), min(p3.y, p4.y)).floor();
    let max_x = max(max(p1.x, p2.x), max(p3.x, p4.x)).ceiling();
    let max_y = max(max(p1.y, p2.y), max(p3.y, p4.y)).ceiling();

    if max_x <= min_x {
        max_x = min_x + 1.0;
    }
    if max_y <= min_y {
        max_y = min_y + 1.0;
    }
    return rect(min_x, min_y, max_x, max_y);
}

fn sync_selection_bounds() {
    let bounds = current_transformed_bounds!();
    if bounds == () {
        return;
    }
    session.set_selection_rect(bounds.x1.to_int(), bounds.y1.to_int(), bounds.x2.to_int(), bounds.y2.to_int());
}

fn restore_base_selection_if_not_applied() {
    if pasted_once || base_selection == () {
        return;
    }
    session.set_selection_rect(
        base_selection.x1.to_int(),
        base_selection.y1.to_int(),
        base_selection.x2.to_int(),
        base_selection.y2.to_int()
    );
}

// ---------------------------------------------------------------------------
// Draw
// ---------------------------------------------------------------------------

fn draw() {
    if session.mode != rotation_mode && session.mode != scale_mode {
        return;
    }
    if in_progress {
        sync_selection_bounds!();
    }
    let algo_addr = session.get_setting("rotate-scale/algo").as_string();
    if algo_addr != () {
        draw_text(vec2(10.0, 86.0), `Algorithm: ${algo_addr}`, rgb8(0xff, 0x33, 0x66));
        if session.mode == rotation_mode {
            draw_text(vec2(10.0, 66.0), `Angle: ${rotation_degrees}`, rgb8(0xff, 0x33, 0x66));
        }
        if session.mode == scale_mode {
            draw_text(vec2(10.0, 66.0), `Scale: ${scale_x}, ${scale_y}`, rgb8(0xff, 0x33, 0x66));
        }
    }
    
    let view = session.view(session.active_view_id);
    let offset_x = session.offset_x + view.offset.x;
    let offset_y = session.offset_y + view.offset.y;
    let d = view.zoom;

    if pivot == () {
        return;
    }
    let x1 = pivot.x * d + offset_x;
    let y1 = pivot.y * d + offset_y;
    let pivot_color = if pivot_locked { PIVOT_COLOR_LOCKED } else { PIVOT_COLOR_UNLOCKED };

    // pivot crosshair
    draw_line(vec2(x1 - PIVOT_HALF, y1), vec2(x1 + PIVOT_HALF, y1), pivot_color);
    draw_line(vec2(x1, y1 - PIVOT_HALF), vec2(x1, y1 + PIVOT_HALF), pivot_color);

    if drag_start == () {
        return;
    }
}

fn shade(encoder) {
    if !in_progress {
        return;
    }
    let algo_addr = session.get_setting("rotate-scale/algo").as_string();
    if algo_addr == () || algo_addr == "" {
        throw "rotate-scale/algo setting is required";
    }
    let pass_fn = session.get_plugin_fn(algo_addr);
    let draw_to_render = apply_queue.pop() == "draw_to_render";
    let target_texture = if draw_to_render {
        renderer.view_render_texture(active_view_id)
    } else {
        renderer.view_staging_texture(session.active_view_id)
    };
    if draw_to_render {
        pasted_once = true;
    }

    let batch = renderer.sprite_singleton_batch(
        8, 8,
        rect(0.0, 0.0, 8.0, 8.0),
        base_selection.to_rect_f64(),
        0.0,
        rgb8(0, 0, 0, 0),
        if draw_to_render { 1.0 } else { 0.9 });
    let vertices = batch.vertices();

    let t1 = mat4_translation(-pivot.x, -pivot.y);
    let t2 = mat4_translation(pivot.x, pivot.y);
    let transform = if last_mode == rotation_mode {
        let rotation_radians = degrees_to_radians(rotation_degrees);
        let r = mat4_rotation_z(rotation_radians);
        t2 * r * t1
    } else {
        let s = mat4_scale(scale_x, scale_y);
        t2 * s * t1
    };

    pass_fn.invoke([encoder, transform, target_texture, clipboard, vertices]);
}
