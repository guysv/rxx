fn init() {
    let wgsl = read_file("cleanedge.wgsl");
    let rotation_mode = script_mode("visual (rotation)");
    let rotation_angle = 0.0;
    let accumulated_angle = 0.0;
    let rotation_center = ();
    let pivot = ();
    let drag_start = ();
    let last_p = ();
    let clipboard = renderer.create_render_texture(8, 8);
    let in_progress = false;
    let active_view_id = ();
    let shader = renderer.create_shader_module(wgsl);
    let pipeline = renderer.create_render_pipeline_with_texture(shader, "vs_main", "fs_main");
    register_command("selection/rotate", "Rotates the selection");
    print(`dev.rxx initialized`);
}

fn unload() {
    if in_progress {
        queue_effect(effect_view_damaged(active_view_id));
        if session.mode == rotation_mode {
            session.switch_mode(MODE_NORMAL);
        }
    }
}

fn mouse_input(state, button, cursor) {
    if session.mode != rotation_mode {
        return;
    }
    print(`mouse_input: ${state}, ${button}, ${cursor}`);
    let view = session.view(session.active_view_id);
    let d = view.zoom;
    let cursor = vec2(cursor.x + d/4, cursor.y + d/4);
    let p = session.active_view_sub_coords(cursor, 2);
    print(`mouse_input: ${p}`);
    if state == INPUT_STATE_PRESSED && button == MOUSE_BUTTON_RIGHT && session.mode == rotation_mode {
        print(`new pivot: ${p}`);
        if p == pivot {
            pivot = ();
        } else {
            pivot = p;
        }
    }

    if state == INPUT_STATE_PRESSED && button == MOUSE_BUTTON_LEFT && session.mode == rotation_mode {
        drag_start = p;
    }

    if state == INPUT_STATE_RELEASED && button == MOUSE_BUTTON_LEFT && session.mode == rotation_mode {
        accumulated_angle = rotation_angle;
        drag_start = ();
        last_p = ();
    }
}

fn vector_angle(pivot, from_pt, to_pt) {
    let v1 = from_pt - pivot;
    let v2 = to_pt - pivot;
    let dot = v1.x * v2.x + v1.y * v2.y;
    let det = v1.x * v2.y - v1.y * v2.x;
    // print(`v1: ${v1}, v2: ${v2}, dot: ${dot}, det: ${det}`);
    return atan(det, dot);
}

fn cursor_moved(p) {
    if drag_start != () {
        let view = session.view(session.active_view_id);
        let zoom = view.zoom;
        let offset = vec2(session.offset_x + view.offset.x, session.offset_y + view.offset.y);
        let pivot_session = pivot * zoom + offset;
        if p == pivot_session || p == drag_start || pivot_session == drag_start {
            print(`p == pivot_session || p == drag_start || pivot_session == drag_start`);
        } else {
            last_p = p;
            let drag_start_session = drag_start * zoom + offset;
            let angle = vector_angle(pivot_session, drag_start_session, p.to_vec2());
            rotation_angle = accumulated_angle + angle;
        }
    }
}

fn draw() {
    if session.mode == rotation_mode {    
        let view = session.view(session.active_view_id);
        let offset_x = session.offset_x + view.offset.x;
        let offset_y = session.offset_y + view.offset.y;
        let offset = vec2(offset_x, offset_y);
        let d = view.zoom;

        if pivot != () {
            let x1 = pivot.x * d + offset_x;
            let y1 = pivot.y * d + offset_y;
            draw_line(vec2(x1-6.0, y1), vec2(x1+6.0, y1), rgb8(0xff, 0xff, 0x00));
            draw_line(vec2(x1, y1-6.0), vec2(x1, y1+6.0), rgb8(0xff, 0xff, 0x00));
            if drag_start != () {
                let drag_start_session = drag_start * d + offset;
                draw_line(drag_start_session, vec2(x1, y1), rgb8(0xff, 0xff, 0x00));
                if last_p != () {
                    // let last_p_session = last_p.to_vec2() * d + offset;
                    draw_line(last_p.to_vec2(), vec2(x1, y1), rgb8(0xff, 0xff, 0x00));
                }
            }
        }
    } 
}

fn shade(encoder) {
    if in_progress {
        let staging_texture = renderer.view_staging_texture(session.active_view_id);

        let view = session.view(session.active_view_id);
        let batch = renderer.sprite_singleton_batch(
            8, 8,
            rect(0.0, 0.0, 8.0, 8.0),
            session.selection.to_rect_f64(),
            0.0,
            rgb8(0, 0, 0, 0),
            0.9);
        let vertices = batch.vertices();
        let vertex_buffer = renderer.create_vertex_buffer_from_sprite_vertices(vertices);

        let t1 = mat4_translation(-pivot.x, -pivot.y);
        let r = mat4_rotation_z(rotation_angle);
        print(`rotation_angle: ${rotation_angle}`);
        let t2 = mat4_translation(pivot.x, pivot.y);
        let transform = t2 * r * t1;
        let transform_bind_group = renderer.create_ortho_custom_transform_bind_group(view.frame_width, view.frame_height, transform);
        let clipboard_bind_group = renderer.create_texture_sampler_bind_group(clipboard);

        let pass = encoder.begin_render_pass("cleanedge", [color_attachment(staging_texture, load_load(), store_store())]);
        pass.set_pipeline(pipeline);
        pass.set_bind_group(0, transform_bind_group);
        pass.set_bind_group(1, clipboard_bind_group);
        pass.set_vertex_buffer(0, vertex_buffer);
        pass.draw(6, 1, 0, 0);
    }
}

fn switch_mode() {
    if in_progress && session.prev_mode == rotation_mode {
        in_progress = false;
        queue_effect(effect_view_damaged(active_view_id));
    }
}

fn cmd_selection_rotate(args) {
    if session.selection != () {
        drag_start = ();
        last_p = ();
        in_progress = true;
        rotation_angle = 0.0;
        accumulated_angle = 0.0;
        let selection = session.selection;
        pivot = selection.center();
        active_view_id = session.active_view_id;
        renderer.upload_selection_to_texture(session, clipboard);
        queue_active_view_rect_clear(selection);
        session.switch_mode(rotation_mode);
    }
}